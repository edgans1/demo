<!DOCTYPE html>
<html>
<head>
	<title>demo</title>
	<meta http-equiv="Cotent-Type" content="text/html"; charset="utf-8">
	<script>
		// 	let a = 10;
		// 	var b =1;
		// }
		// alert(b);
		var a = [];
		for (let i =0; i<10; i++){
			a[i] = function(){
				console.log(i);
			};
		}
		a[6]();

		var a =[];
		for(var i = 0;i<10; i++){
			a[i] = function(){
				console.log(i);
			}
		}
		a[6]();

		for(let i = 0; i<3; i++){
			let i ="abc";
			console.log(i);
		}

		console.log(foo);
		var foo = 2;

		let bar = 23;
		console.log(bar);
		let tmp;
		var temp = 123;
		if (true){
			tmp = 'abc';
			
		}

		//在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。
		
		if (true){
			//TDZ 开始
			//tmp = 'abc';
			//console.log(tmp);

			let tmp;//TDZ结束
			console.log(tmp);

			tmp = 123;
			console.log(tmp);
		}

		//typeof x;
		//let x;
		
		console.log(typeof Numbers);

		/*function bar (x = y, y =2){
			return[x,y];
		}
		bar();*/
		//上面代码中，调用bar函数之所以报错（某些实现可能不报错），是因为参数x默认值等于另一个参数y，而此时y还没有声明，属于”死区“。如果y的默认值是x，就不会报错，因为此时x已经声明了。
		function ar(x =2, y =x){
			return[x, y];
		}
		console.log(ar());
		//不报错
		var x = x;
		//报错
		//let x = x;

		var temp = new Date();
		function f(){
			console.log(temp);
			if(false){
				var temp = 'hello world'
			}
		}
		alert(f());

		var s ='hello';
		for(var i =0; i<s.length;i++){
			//console.log(s[i]);
		}
		//console.log(i);

		function f1(){
			let n =5;
			if(true){
				let n = 10;
			}
			console.log(n);
		}
		f1();

		//ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。
		
		if(true){
			function f(){}
		}

		//情况二
		try{
			function f(){}
		}catch(e){
			
		}
	</script>
</body>
</html>